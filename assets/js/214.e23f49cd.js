(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{1401:function(t,_,o){"use strict";o.r(_);var e=o(10),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,o=t._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h2",{attrs:{id:"一、js内置对象"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一、js内置对象"}},[t._v("#")]),t._v(" 一、JS内置对象")]),t._v(" "),o("blockquote",[o("p",[t._v("所谓的内置对象 指的是："),o("code",[t._v("JavaScript")]),t._v("本身就自己有的对象 可以直接拿来就用。例如"),o("code",[t._v("Array")]),t._v(" "),o("code",[t._v("String")]),t._v(" 等等。"),o("code",[t._v("JavaScript")]),t._v("一共有12内置对象")])]),t._v(" "),o("p",[o("strong",[t._v("函数类型(10个)")])]),t._v(" "),o("ul",[o("li",[o("code",[t._v("String")])]),t._v(" "),o("li",[o("code",[t._v("Number")])]),t._v(" "),o("li",[o("code",[t._v("Boolean")])]),t._v(" "),o("li",[o("code",[t._v("Array")])]),t._v(" "),o("li",[o("code",[t._v("Function")])]),t._v(" "),o("li",[o("code",[t._v("Date")])]),t._v(" "),o("li",[o("code",[t._v("RegExp")])]),t._v(" "),o("li",[o("code",[t._v("Error")])]),t._v(" "),o("li",[o("code",[t._v("Object")])]),t._v(" "),o("li",[o("code",[t._v("Event")])])]),t._v(" "),o("blockquote",[o("p",[t._v("函数类型 有 "),o("code",[t._v("__proto__")]),t._v("和 "),o("code",[t._v("prototype")]),t._v(" 属性")])]),t._v(" "),o("p",[o("strong",[t._v("对象类型(2个)")])]),t._v(" "),o("ul",[o("li",[o("code",[t._v("Math")])]),t._v(" "),o("li",[o("code",[t._v("JSON")])])]),t._v(" "),o("blockquote",[o("p",[t._v("对象类型只有"),o("code",[t._v("__proto__")]),t._v("属性")])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/1480597-9b6c5ca4a84f967c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})]),t._v(" "),o("h2",{attrs:{id:"二、js原型链"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#二、js原型链"}},[t._v("#")]),t._v(" 二、JS原型链")]),t._v(" "),o("h3",{attrs:{id:"_2-1-概述"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-概述"}},[t._v("#")]),t._v(" 2.1 概述")]),t._v(" "),o("p",[o("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/1480597-86427eafb257f868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})]),t._v(" "),o("ul",[o("li",[t._v("每个函数都有 "),o("code",[t._v("prototype")]),t._v(" 属性，除了 "),o("code",[t._v("Function.prototype.bind()")]),t._v("，该属性指向原型。")]),t._v(" "),o("li",[t._v("每个对象都有 "),o("code",[t._v("__proto__")]),t._v(" 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 "),o("code",[t._v("[[prototype]]")]),t._v("，但是 "),o("code",[t._v("[[prototype]]")]),t._v(" 是内部属性，我们并不能访问到，所以使用 "),o("code",[t._v("__proto__")]),t._v(" 来访问")]),t._v(" "),o("li",[t._v("对象可以通过 "),o("strong",[t._v("proto")]),t._v(" 来寻找不属于该对象的属性，"),o("code",[t._v("__proto__")]),t._v(" 将对象连接起来组成了原型链")])]),t._v(" "),o("blockquote",[o("p",[t._v("打开浏览器的控制面板，随便输入一个"),o("code",[t._v("JS")]),t._v("内置的构造器函数，比如"),o("code",[t._v("Array")]),t._v("，控制台输出的是一个名为"),o("code",[t._v("Array")]),t._v("的函数体，这好像并没有什么稀奇的，但是，当你接着输入"),o("code",[t._v("Array.prototype")]),t._v("，控制面板输出了一堆我们经常用到的"),o("code",[t._v("Array")]),t._v("构造器的方法，把目光转移到最下方，有一个叫"),o("code",[t._v("__proto__")]),t._v("的属性，好奇的点开。列表列出的不是"),o("code",[t._v("Object")]),t._v("构造器的方法么，里边有我们非常熟悉的"),o("code",[t._v("hasOwnProperty")]),t._v("还有"),o("code",[t._v("toString")]),t._v("等方法。如果"),o("code",[t._v("Array")]),t._v("是构造器，那么控制面板输出的"),o("code",[t._v("Array.prototype")]),t._v("的所有属性中"),o("code",[t._v("constructor")]),t._v("又是什么构造器？点开看看，之后就像身处德罗斯特效应中一样，"),o("code",[t._v("__proto__")]),t._v("和"),o("code",[t._v("constructor")]),t._v("，还有"),o("code",[t._v("Array")]),t._v("构造器中常用的方法名不断的出现，一层套一层，一层层展开，没有尽头")])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/343.png",alt:""}})]),t._v(" "),o("blockquote",[o("p",[t._v("拿"),o("code",[t._v("Array")]),t._v("举例，"),o("code",[t._v("Array.prototype")]),t._v("中有一个"),o("code",[t._v("constructor")]),t._v("属性，这个属性的值就是"),o("code",[t._v("Array")]),t._v("构造器自己")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("Array.prototype.constructor === Array //true\n")])])]),o("h3",{attrs:{id:"_2-2-prototype"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-prototype"}},[t._v("#")]),t._v(" 2.2 prototype")]),t._v(" "),o("blockquote",[o("p",[t._v("这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外")])]),t._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" fun "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("prototype")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),o("blockquote",[o("p",[t._v("如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 "),o("code",[t._v("prototype")]),t._v(" 属性的")])]),t._v(" "),o("h4",{attrs:{id:"_2-2-1-prototype-如何产生的"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-prototype-如何产生的"}},[t._v("#")]),t._v(" 2.2.1 prototype 如何产生的")]),t._v(" "),o("blockquote",[o("p",[t._v("当我们声明一个函数时，这个属性就被自动创建了")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("function Foo() {}\n")])])]),o("blockquote",[o("p",[t._v("并且这个属性的值是一个对象（也就是原型），只有一个属性 "),o("code",[t._v("constructor")])])]),t._v(" "),o("ul",[o("li",[o("code",[t._v("constructor")]),t._v(" 对应着构造函数，也就是 "),o("code",[t._v("Foo")])])]),t._v(" "),o("h4",{attrs:{id:"_2-2-2-constructor"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-constructor"}},[t._v("#")]),t._v(" 2.2.2 constructor")]),t._v(" "),o("blockquote",[o("p",[o("code",[t._v("constructor")]),t._v("是一个公有且不可枚举的属性。一旦我们改变了函数的 "),o("code",[t._v("prototype")]),t._v(" ，那么新对象就没有这个属性了（当然可以通过原型链取到 "),o("code",[t._v("constructor")]),t._v("）")])]),t._v(" "),o("p",[t._v("那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：")]),t._v(" "),o("ul",[o("li",[t._v("让实例对象知道是什么函数构造了它")]),t._v(" "),o("li",[t._v("如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 "),o("code",[t._v("xx.constructor.method")]),t._v(" 来扩展")])]),t._v(" "),o("h3",{attrs:{id:"_2-3-proto"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-proto"}},[t._v("#")]),t._v(" 2.3 "),o("code",[t._v("__proto__")])]),t._v(" "),o("blockquote",[o("p",[t._v("这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 "),o("code",[t._v("[[prototype]]")]),t._v("，但是 "),o("code",[t._v("[[prototype]]")]),t._v(" 是内部属性，我们并不能访问到，所以使用 "),o("code",[t._v("__proto__")]),t._v(" 来访问")])]),t._v(" "),o("ul",[o("li",[t._v("因为在 "),o("code",[t._v("JS")]),t._v(" 中是没有类的概念的，为了实现类似继承的方式，通过 "),o("code",[t._v("__proto__")]),t._v(" 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性")])]),t._v(" "),o("h4",{attrs:{id:"_2-3-1-实例对象的-proto-如何产生的"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-实例对象的-proto-如何产生的"}},[t._v("#")]),t._v(" 2.3.1 实例对象的 "),o("code",[t._v("_proto_")]),t._v(" 如何产生的")]),t._v(" "),o("blockquote",[o("p",[t._v("当我们使用 "),o("code",[t._v("new")]),t._v(" 操作符时，生成的实例对象拥有了 "),o("code",[t._v("__proto__")]),t._v("属性")])]),t._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("Foo")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个函数是 Function 的实例对象")]),t._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function 就是一个语法糖")]),t._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 内部调用了 new Function(...)")]),t._v("\n")])])]),o("blockquote",[o("p",[t._v("所以可以说，在 "),o("code",[t._v("new")]),t._v(" 的过程中，新对象被添加了 "),o("code",[t._v("__proto__")]),t._v(" 并且链接到构造函数的原型上")])]),t._v(" "),o("h4",{attrs:{id:"_2-3-2-new-的过程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-new-的过程"}},[t._v("#")]),t._v(" 2.3.2 new 的过程")]),t._v(" "),o("ul",[o("li",[t._v("新生成了一个对象")]),t._v(" "),o("li",[t._v("链接到原型")]),t._v(" "),o("li",[t._v("绑定 "),o("code",[t._v("this")])]),t._v(" "),o("li",[t._v("返回新对象")])]),t._v(" "),o("blockquote",[o("p",[t._v("在调用 "),o("code",[t._v("new")]),t._v(" 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 "),o("code",[t._v("new")])])]),t._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个空的对象")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获得构造函数")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" Con "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 链接到原型")]),t._v("\n\tobj"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Con")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n    "),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 绑定 this，执行构造函数")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" result "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("Con")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 确保 new 出来的是个对象")]),t._v("\n    "),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" result "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token string"}},[t._v("'object'")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" result "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" obj\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),o("ul",[o("li",[t._v("对于实例对象来说，都是通过 "),o("code",[t._v("new")]),t._v(" 产生的，无论是 "),o("code",[t._v("function Foo()")]),t._v(" 还是 "),o("code",[t._v("let a = { b : 1 }")])]),t._v(" "),o("li",[t._v("对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 "),o("code",[t._v("new Object()")]),t._v("的方式创建对象需要通过作用域链一层层找到 "),o("code",[t._v("Object")]),t._v("，但是你使用字面量的方式就没这个问题。")])]),t._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function 就是个语法糖")]),t._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 内部等同于 new Function()")]),t._v("\n"),o("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" b"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个字面量内部也是使用了 new Object()")]),t._v("\n")])])]),o("p",[o("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/1480597-e4a91031a78eb153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})]),t._v(" "),o("blockquote",[o("p",[t._v("这里"),o("code",[t._v("Array")]),t._v(" 内置对象 且是函数类型。所以"),o("code",[t._v("Array")]),t._v("有"),o("code",[t._v("__proto__")]),t._v("属性 指向的是函数类型 "),o("code",[t._v("(function（）{})")]),t._v("。所以当我们在输出"),o("code",[t._v("Array.__proto__.proto__")]),t._v(";就会返回对象类型"),o("code",[t._v("(Object{})")]),t._v(".但是再向上就"),o("code",[t._v("null")]),t._v("。因为"),o("code",[t._v("Object")]),t._v("就是父类了。所有的继承自"),o("code",[t._v("Object")]),t._v("。")])]),t._v(" "),o("ul",[o("li",[o("code",[t._v("JS")]),t._v("内置构造器其中之一的"),o("code",[t._v("Array")]),t._v("原本就是一个函数，而这个函数就是"),o("code",[t._v("Function")]),t._v("的"),o("code",[t._v("prototype")]),t._v("，所以"),o("code",[t._v("Function.prototype")]),t._v("有的方法，"),o("code",[t._v("JS")]),t._v("内置构造器都有，比如"),o("code",[t._v("call()")]),t._v("、"),o("code",[t._v("apply()")]),t._v("、"),o("code",[t._v("bind()")]),t._v("等（其实我们自定义的函数也是继承自"),o("code",[t._v("Function.prototype")]),t._v("，所以我们自己也可以定义构造器）。而"),o("code",[t._v("Function.prototype")]),t._v("的进化链指针又指向了"),o("code",[t._v("Object.prototype")])])]),t._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[o("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数组实例的__proto__指向构造器的原型")]),t._v("\n\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),o("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype \n")])])]),o("h3",{attrs:{id:"_2-4-总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-总结"}},[t._v("#")]),t._v(" 2.4 总结")]),t._v(" "),o("ul",[o("li",[o("code",[t._v("Object")]),t._v(" 是所有对象的爸爸，所有对象都可以通过 "),o("code",[t._v("__proto__")]),t._v(" 找到它")]),t._v(" "),o("li",[o("code",[t._v("Function")]),t._v(" 是所有函数的爸爸，所有函数都可以通过 "),o("code",[t._v("__proto__")]),t._v(" 找到它")]),t._v(" "),o("li",[o("code",[t._v("Function.prototype")]),t._v(" 和 "),o("code",[t._v("Object.prototype")]),t._v(" 是两个特殊的对象，他们由引擎来创建")]),t._v(" "),o("li",[t._v("除了以上两个特殊对象，其他对象都是通过构造器 "),o("code",[t._v("new")]),t._v(" 出来的")]),t._v(" "),o("li",[t._v("函数的 "),o("code",[t._v("prototype")]),t._v(" 是一个对象，也就是原型")]),t._v(" "),o("li",[t._v("对象的 "),o("code",[t._v("__proto__")]),t._v(" 指向原型， "),o("code",[t._v("__proto__")]),t._v("将对象和原型连接起来组成了原型链")])]),t._v(" "),o("p",[o("strong",[t._v("关于原型有3个相关的概")]),t._v("念:")]),t._v(" "),o("ul",[o("li",[t._v("函数对象的"),o("code",[t._v("prototype")]),t._v("属性, 可以称之为显式原型属性(简称: 显式原型)")]),t._v(" "),o("li",[t._v("实例对象的"),o("code",[t._v("__proto__")]),t._v("属性, 可以称之为隐式原型属性(简称: 隐式原型)")]),t._v(" "),o("li",[t._v("原型对象: 也就是"),o("code",[t._v("prototype")]),t._v("属性和"),o("code",[t._v("_proto__")]),t._v("属性指向的对象")])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png",alt:""}})]),t._v(" "),o("blockquote",[o("p",[t._v("图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线")])]),t._v(" "),o("h2",{attrs:{id:"三、json和math"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#三、json和math"}},[t._v("#")]),t._v(" 三、JSON和Math")]),t._v(" "),o("blockquote",[o("p",[o("code",[t._v("JS")]),t._v("内置的构造器函数都可以使用"),o("code",[t._v("new")]),t._v("关键字实例化一个对象，我们称实例化后的这个对象就是某某构造器的一个实例")])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/344.png",alt:""}})]),t._v(" "),o("blockquote",[o("p",[t._v("我们试试"),o("code",[t._v("JSON")]),t._v(" 和"),o("code",[t._v("Math")]),t._v(" 能不能实例化对象")])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/345.png",alt:""}})]),t._v(" "),o("blockquote",[o("p",[o("code",[t._v("JSON")]),t._v("和"),o("code",[t._v("Math")]),t._v("不是构造器函数，他们是普通的对象。只有构造器函数才能使用"),o("code",[t._v("new")]),t._v("关键字实例化一个对象，而"),o("code",[t._v("JSON")]),t._v("和"),o("code",[t._v("Math")]),t._v("已经是对象了，所以我们可以不用实例化直接使用"),o("code",[t._v("JSON")]),t._v("和"),o("code",[t._v("Math")]),t._v("中的属性和方法")])]),t._v(" "),o("ul",[o("li",[t._v("所以"),o("code",[t._v("JSON")]),t._v("和"),o("code",[t._v("Math")]),t._v("不属于"),o("code",[t._v("10")]),t._v("个构造器函数，但他们"),o("code",[t._v("12")]),t._v("个共同属于"),o("code",[t._v("Javascript")]),t._v("的内置对象")])]),t._v(" "),o("h2",{attrs:{id:"四、更多参考"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#四、更多参考"}},[t._v("#")]),t._v(" 四、更多参考")]),t._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/2",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之从原型到原型链"),o("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);