(window.webpackJsonp=window.webpackJsonp||[]).push([[606],{1143:function(e,t,s){"use strict";s.r(t);var n=s(10),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"开发指南篇-4：数据驱动与拼图游戏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发指南篇-4：数据驱动与拼图游戏"}},[e._v("#")]),e._v(" 开发指南篇 4：数据驱动与拼图游戏")]),e._v(" "),s("p",[e._v("数据驱动是 Vue 框架的核心特性之一，也是 Vue 响应式原理的具体体现，相信大家对其应该深有体会，尤其是在操作数据来触发页面更新的时候。")]),e._v(" "),s("p",[e._v("为了让大家更加了解数据驱动的理念，并解决使用过程中可能出现的一系列问题，本文将结合比较常见和简单的 “拼图游戏” 来展示 Vue 数据驱动的魅力所在。")]),e._v(" "),s("h2",{attrs:{id:"效果展示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#效果展示"}},[e._v("#")]),e._v(" 效果展示")]),e._v(" "),s("p",[e._v("首先我们先来看一下实现的 “拼图游戏” 的动态效果：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/31.png",alt:""}})]),e._v(" "),s("p",[e._v("在不操作 "),s("code",[e._v("DOM")]),e._v(" 的情况下实现以上功能其实需要我们对 Vue 数据驱动及数据可视化有一个非常清楚的认知，在操作数据的同时驱动可视化界面的还原。")]),e._v(" "),s("h2",{attrs:{id:"关键代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关键代码"}},[e._v("#")]),e._v(" 关键代码")]),e._v(" "),s("p",[e._v("接下来我们来看一下实现该拼图游戏的功能点及关键代码：")]),e._v(" "),s("h3",{attrs:{id:"游戏面板的构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#游戏面板的构建"}},[e._v("#")]),e._v(" 游戏面板的构建")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('\x3c!-- HTML 部分 --\x3e\n<ul class="puzzle-wrap">\n    <li \n        :class="{\'puzzle\': true, \'puzzle-empty\': !puzzle}" \n        v-for="(puzzle, index) in puzzles"\n        :key="index"\n        v-text="puzzle"\n    ></li>\n</ul>\n\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 数据部分\nexport default {\n    data() {\n        return {\n            puzzles: Array.from({ length: 15 }, (value, index) => index + 1)\n        }\n    },\n}\n\n")])])]),s("p",[e._v("上方我们使用 "),s("code",[e._v("v-for")]),e._v(" 循环构建了从 1 ～ 15 按顺序排列的方块格子，也就是拼图完成时候的顺序，但是拼图游戏一开始数字的顺序应该是无序的，也是随机打乱的，那么我们怎么实现呢？可以使用下方的随机排列函数：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function shuffle(arr) {\n    let len = arr.length\n    \n    for (let i = 0; i < len - 1; i++) {\n        let idx = Math.floor(Math.random() * (len - i))\n        let temp = arr[idx]\n        arr[idx] = arr[len - i - 1]\n        arr[len - i - 1] = temp\n    }\n    \n    return arr\n}\n\n")])])]),s("p",[e._v("该函数中我们使用 "),s("code",[e._v("Math.random()")]),e._v(" 来返回 0 和 1 之间的伪随机数，可能为 0，但总是小于1，[0, 1)，而通过这一特性我们可以实现生成 n-m，包含 n 但不包含 m 的整数，具体步骤如下：")]),e._v(" "),s("ul",[s("li",[e._v("第一步算出 "),s("code",[e._v("m-n")]),e._v(" 的值，假设等于 w")]),e._v(" "),s("li",[e._v("第二步 "),s("code",[e._v("Math.random() * w")])]),e._v(" "),s("li",[e._v("第三步 "),s("code",[e._v("Math.random() * w + n")])]),e._v(" "),s("li",[e._v("第四步 "),s("code",[e._v("Math.floor(Math.random() * w + n)")])])]),e._v(" "),s("p",[e._v("在 "),s("code",[e._v("shuffle")]),e._v(" 函数中 n 值永远是 0，而 w（即 len - i） 值随着循环 i 值的变大而不断减小。")]),e._v(" "),s("blockquote",[s("p",[e._v("在上面的算法里，我们每一次循环从前 len - i 个元素里随机一个位置，将这个元素和第 len - i 个元素进行交换，迭代直到 i = len - 1 为止。")])]),e._v(" "),s("p",[e._v("这一便实现了数组的随机打乱。最后我们需要在数组末尾追加一个空值来显示唯一一个空白格子：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("this.puzzles.push('');\n\n")])])]),s("h3",{attrs:{id:"交换方块位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#交换方块位置"}},[e._v("#")]),e._v(" 交换方块位置")]),e._v(" "),s("p",[e._v("实现随机数字后，当我们点击方块，如果其上下左右存在为空的格子就需要将其进行交换，而由于是数据驱动界面，这里我们便需要交换两者在数组中的位置来实现：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export default {\n    methods: {\n        \n        // 点击方块\n        moveFn(index) {\n            let puzzles = this.puzzles\n\n            // 获取点击位置上下左右的值\n            let leftNum = this.puzzles[index - 1],\n                rightNum = this.puzzles[index + 1],\n                topNum = this.puzzles[index - 4],\n                bottomNum = this.puzzles[index + 4]\n\n            // 和为空的位置交换数值\n            if (leftNum === '' && index % 4) {\n                this.setPuzzle(index, -1)\n            } else if (rightNum === '' && 3 !== index % 4) {\n                this.setPuzzle(index, 1)\n            } else if (topNum === '') {\n                this.setPuzzle(index, -4)\n            } else if (bottomNum === '') {\n                this.setPuzzle(index, 4)\n            }\n        },\n\n        // 设置数组值\n        setPuzzle(index, num) {\n            let curNum = this.puzzles[index]\n            \n            this.$set(this.puzzles, index + num, curNum)\n            this.$set(this.puzzles, index, '')\n        },\n    }\n}\n\n")])])]),s("p",[e._v("由于是 16 宫格的拼图，所以我们在点击获取位置的时候需要考虑边界情况，比如第 4 个格子为空，我们点击第 5 个格子不应该交换它们，因为在界面上第 4 个格子不在第 5 个格子的左侧，所以我们使用 "),s("code",[e._v("index % 4")]),e._v(" 的方法来进行边界的判断，同时使用 Vue 提供的 "),s("code",[e._v("$set")]),e._v(" 方法来将响应属性添加到数组上。")]),e._v(" "),s("h3",{attrs:{id:"校验是否过关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#校验是否过关"}},[e._v("#")]),e._v(" 校验是否过关")]),e._v(" "),s("p",[e._v("最后我们需要校验游戏是否过关，我们只需要在最后一个格子为空时去进行校验即可：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if (this.puzzles[15] === '') {\n    const newPuzzles = this.puzzles.slice(0, 15)\n    const isPass = newPuzzles.every((e, i) => e === i + 1)\n\n    if (isPass) {\n        alert ('恭喜，闯关成功！')\n    }\n}\n\n")])])]),s("p",[e._v("我们使用数组的 "),s("code",[e._v("every")]),e._v(" 方法来简化代码的复杂度，当所有数字大小和对应的数组下标 + 1 相吻合时即会返回 "),s("code",[e._v("true")]),e._v("。")]),e._v(" "),s("p",[e._v("如此我们便完成了一个简单拼图游戏的功能。")]),e._v(" "),s("h2",{attrs:{id:"盲点及误区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#盲点及误区"}},[e._v("#")]),e._v(" 盲点及误区")]),e._v(" "),s("p",[e._v("在实现拼图游戏后，有些同学可能会存在一些疑惑，比如：数组赋值为什么要用 $set 方法？数组随机打乱为什么不用 sort 排序呢？下面便来进行讲解：")]),e._v(" "),s("h3",{attrs:{id:"为什么要用-set-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用-set-方法"}},[e._v("#")]),e._v(" 为什么要用 $set 方法")]),e._v(" "),s("p",[e._v("大家应该都知道如果不用 "),s("code",[e._v("$set")]),e._v(" 方法我们可以直接通过操作数组索引的形式对数组进行赋值，从而交换拼图的中两者的数据：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 设置数组值\nsetPuzzle(index, num) {\n    let curNum = this.puzzles[index]\n    \n    this.puzzles[index + num] = curNum\n    this.puzzles[index] = ''\n    \n    // this.$set(this.puzzles, index + num, curNum)\n    // this.$set(this.puzzles, index, '')\n}\n\n")])])]),s("p",[e._v("但是你会发现这样做数据是改变了，但是页面并没有因此重新渲染，这是为什么呢？其实 Vue 官方已经给出了明确的答案：")]),e._v(" "),s("blockquote",[s("p",[e._v("由于 JavaScript 的限制，Vue 不能检测以下变动的数组：")]),e._v(" "),s("ul",[s("li",[e._v("当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue")]),e._v(" "),s("li",[e._v("当你修改数组的长度时，例如：vm.items.length = newLength")])])]),e._v(" "),s("p",[e._v("我们这里使用的便是第一种利用索引的方式，由于 Vue 检测不到数组变动，因此页面便无法重绘。同样 Vue 也不能检测对象属性的添加或删除，需要使用 "),s("code",[e._v("Vue.set(object, key, value)")]),e._v(" 方法来实现。")]),e._v(" "),s("p",[e._v("其实还有一种比较取巧的方式便是强制重新渲染 Vue 实例来解决这一问题：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 设置数组值\nsetPuzzle(index, num) {\n    let curNum = this.puzzles[index]\n    \n    this.puzzles[index + num] = curNum\n    this.puzzles[index] = ''\n    \n    this.$forceUpdate() // 迫使 Vue 实例重新渲染\n    \n    // this.$set(this.puzzles, index + num, curNum)\n    // this.$set(this.puzzles, index, '')\n}\n\n")])])]),s("p",[e._v("上方我们使用了 Vue 提供的 "),s("code",[e._v("$forceUpdate")]),e._v(" 方法迫使 Vue 实例重新渲染，这样改变的数据就会被更新的页面中去。但是最好不要这样操作，因为这会导致 Vue 重新遍历此对象所有的属性，一定程度上会影响页面的性能。")]),e._v(" "),s("h3",{attrs:{id:"为什么不用-sort-排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不用-sort-排序"}},[e._v("#")]),e._v(" 为什么不用 sort 排序")]),e._v(" "),s("p",[e._v("其实 sort 方法也能够实现数组的随机排序，代码如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("let puzzleArr = Array.from({ length: 15 }, (value, index) => index + 1);\n\n// 随机打乱数组\npuzzleArr = puzzleArr.sort(() => {\n    return Math.random() - 0.5\n});\n\n")])])]),s("p",[e._v("我们通过使用 "),s("code",[e._v("Math.random()")]),e._v(" 的随机数减去 0.5 来返回一个大于、等于或小于 0 的数，sort 方法会根据接收到的值来对相互比较的数据进行升序或是降序排列。")]),e._v(" "),s("p",[e._v("但是由于 JavaScript 内置排序算法的缺陷性，使用 sort 排序的结果并不随机分布，经过大量的测试你会发现"),s("strong",[e._v("越大的数字出现在越后面的概率越大")]),e._v("。")]),e._v(" "),s("p",[e._v("由于本文并非是一篇介绍 sort 排序的文章，关于论证其缺陷性的话题这里就不进行详细展开了，感兴趣的同学可以进一步进行探究。")]),e._v(" "),s("h2",{attrs:{id:"结语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),s("p",[e._v("本文实例是基于我之前写的一篇关于利用 Vue.js 实现拼图游戏的文章上进行了改进和优化，希望通过这样一个小游戏来强化大家对于 Vue 数据驱动的理解。相比操作 DOM 元素，操作数据其实更加的便捷和快速，可以使用较少的代码来实现一些较为复杂的逻辑。")]),e._v(" "),s("p",[e._v("具体实例代码可以参考："),s("a",{attrs:{href:"https://github.com/luozhihao/vue-project-code/blob/ea7294370af888084be41c10c914b4fedbf3f400/ui-framework-project/src/views/demo/puzzle.vue",target:"_blank",rel:"noopener noreferrer"}},[e._v("puzzle"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"思考-作业"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#思考-作业"}},[e._v("#")]),e._v(" 思考 & 作业")]),e._v(" "),s("ul",[s("li",[e._v("Vue 中监听数据变化的原理是什么？是通过何种方式实现的？")]),e._v(" "),s("li",[e._v("如何论证原生 JS 中 sort 排序后越大的数字出现在越后面的概率越大？")]),e._v(" "),s("li",[e._v("如何使用 "),s("code",[e._v("Math.random()")]),e._v(" 生成 n-m，不包含 n 但包含 m 的整数？")])])])}),[],!1,null,null,null);t.default=a.exports}}]);