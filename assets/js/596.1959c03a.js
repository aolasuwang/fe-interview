(window.webpackJsonp=window.webpackJsonp||[]).push([[596],{1166:function(e,t,n){"use strict";n.r(t);var r=n(10),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"构建实战篇-1：单页应用的基本配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构建实战篇-1：单页应用的基本配置"}},[e._v("#")]),e._v(" 构建实战篇 1：单页应用的基本配置")]),e._v(" "),n("p",[e._v("前几篇文章我们介绍了 Vue 项目构建及运行的前期工作，包括 webpack 的配置、环境变量的使用等，在了解并掌握了这些前期准备工作后，那么接下来我们可以走进 Vue 项目的内部，一探其内部配置的基本构成。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/14.png",alt:""}})]),e._v(" "),n("h2",{attrs:{id:"配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[e._v("#")]),e._v(" 配置")]),e._v(" "),n("h3",{attrs:{id:"_1-路由配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-路由配置"}},[e._v("#")]),e._v(" 1. 路由配置")]),e._v(" "),n("p",[e._v("由于 Vue 这类型的框架都是以一个或多个单页构成，在单页内部跳转并不会重新渲染 HTML 文件，其路由可以由前端进行控制，因此我们需要在项目内部编写相应的路由文件，Vue 会解析这些文件中的配置并进行对应的跳转渲染。")]),e._v(" "),n("p",[e._v("我们来看一下 CLI 给我们生成的 router.js 文件的配置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* router.js */\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Home from './views/Home.vue' // 引入 Home 组件\nimport About from './views/About.vue' // 引入 About 组件\n\nVue.use(Router) // 注册路由\n\nexport default new Router({\n    routes: [{\n        path: '/',\n        name: 'home',\n        component: Home\n    }, {\n        path: '/about',\n        name: 'about',\n        component: About\n    }]\n})\n\n")])])]),n("p",[e._v("这份配置可以算是最基础的路由配置，有以下几点需要进行优化：")]),e._v(" "),n("ul",[n("li",[e._v('如果路由存在二级目录，需要添加 base 属性，否则默认为 "/"')]),e._v(" "),n("li",[e._v("默认路由模式是 hash 模式，会携带 # 标记，与真实 url 不符，可以改为 history 模式")]),e._v(" "),n("li",[e._v("页面组件没有进行按需加载，可以使用 "),n("code",[e._v("require.ensure()")]),e._v(" 来进行优化")])]),e._v(" "),n("p",[e._v("下面是我们优化结束的代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* router.js */\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\n// 引入 Home 组件\nconst Home = resolve => {\n    require.ensure(['./views/Home.vue'], () => {\n        resolve(require('./views/Home.vue'))\n    })\n}\n\n// 引入 About 组件\nconst About = resolve => {\n    require.ensure(['./views/About.vue'], () => {\n        resolve(require('./views/About.vue'))\n    })\n}\n\nVue.use(Router)\n\nlet base = `${process.env.BASE_URL}` // 动态获取二级目录\n\nexport default new Router({\n    mode: 'history',\n    base: base,\n    routes: [{\n        path: '/',\n        name: 'home',\n        component: Home\n    }, {\n        path: '/about',\n        name: 'about',\n        component: About\n    }]\n})\n\n")])])]),n("p",[e._v("改为 history 后我们 url 的路径就变成了 "),n("code",[e._v("http://127.0.0.1:8080/vue/about")]),e._v("，而不是原来的 "),n("code",[e._v("http://127.0.0.1:8080/vue/#/about")]),e._v("，但是需要注意页面渲染 404 的问题，具体可查阅："),n("a",{attrs:{href:"https://router.vuejs.org/zh/guide/essentials/history-mode.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTML5 History 模式"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("而在异步加载的优化上，我们使用了 webpack 提供的 require.ensure() 进行了代码拆分，主要区别在于没有优化前，访问 Home 页面会一起加载 About 组件的资源，因为它们打包进了一个 app.js 中：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/15.png",alt:""}})]),e._v(" "),n("p",[e._v("但是优化过后，它们分别被拆分成了 2.js 和 3.js：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/16.png",alt:""}}),e._v(" "),n("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/17.png",alt:""}})]),e._v(" "),n("p",[e._v("如此，只有当用户点击了某页面，才会加载对应页面的 js 文件，实现了按需加载的功能。")]),e._v(" "),n("blockquote",[n("p",[e._v("webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中。这个新的 chunk 会被 webpack 通过 jsonp 来按需加载。")])]),e._v(" "),n("p",[e._v("关于 "),n("code",[e._v("require.ensure()")]),e._v(" 的知识点可以参考官方文档："),n("a",{attrs:{href:"https://webpack.js.org/api/module-methods/#require-ensure",target:"_blank",rel:"noopener noreferrer"}},[e._v("require.ensure"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("当然，除了使用 require.ensure 来拆分代码，"),n("a",{attrs:{href:"https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue Router"),n("OutboundLink")],1),e._v(" 官方文档还推荐使用动态 "),n("code",[e._v("import")]),e._v(" 语法来进行代码分块，比如上述 require.ensure 代码可以修改为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 引入 Home 组件\nconst Home = () => import('./views/Home.vue');\n\n// 引入 About 组件\nconst About = () => import('./views/About.vue');\n\n")])])]),n("p",[e._v("其余代码可以保持不变，仍然可以实现同样的功能。如果你想给拆分出的文件命名，可以尝试一下 webpack 提供的 "),n("code",[e._v("Magic Comments")]),e._v("（魔法注释）：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Home = () => import(/* webpackChunkName:'home'*/ './views/Home.vue');\n\n")])])]),n("h3",{attrs:{id:"_2-vuex-配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-vuex-配置"}},[e._v("#")]),e._v(" 2. Vuex 配置")]),e._v(" "),n("p",[e._v("除了 vue-router，如果你的项目需要用到 "),n("a",{attrs:{href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vuex"),n("OutboundLink")],1),e._v(" ，那么你应该对它有一定的了解，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。这里我们先来看一下使用 CLI 生成的配置文件 store.js 中的内容：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: {\n\n    },\n    mutations: {\n\n    },\n    actions: {\n\n    }\n})\n\n")])])]),n("p",[e._v("该配置文件便是 Vuex 的配置文件，主要有 4 个核心点：state、mutations、actions 及 getter，详细的介绍大家可以参考官方文档："),n("a",{attrs:{href:"https://vuex.vuejs.org/zh/guide/state.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("核心概念"),n("OutboundLink")],1),e._v("，这里我用一句话介绍它们之间的关系就是："),n("strong",[e._v("我们可以通过 actions 异步提交 mutations 去 修改 state 的值并通过 getter 获取")]),e._v("。")]),e._v(" "),n("p",[e._v("需要注意的是不是每一个项目都适合使用 Vuex，如果你的项目是中大型项目，那么使用 Vuex 来管理错综复杂的状态数据是很有帮助的，而为了后期的拓展性和可维护性，这里不建议使用 CLI 生成的一份配置文件来管理所有的状态操作，我们可以把它拆分为以下目录：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── moduleA.js    # A模块\n        └── moduleB.js    # B模块\n\n")])])]),n("p",[n("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/18.png",alt:""}})]),e._v(" "),n("p",[e._v("与单个 store.js 文件不同的是，我们按模块进行了划分，每个模块中都可以包含自己 4 个核心功能。比如模块 A 中：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* moduleA.js */\n\nconst moduleA = {\n    state: { \n        text: 'hello'\n    },\n    mutations: {\n        addText (state, txt) {\n            // 这里的 `state` 对象是模块的局部状态\n            state.text += txt\n        }\n    },\n    \n    actions: {\n        setText ({ commit }) {\n            commit('addText', ' world')\n        }\n    },\n\n    getters: {\n        getText (state) {\n            return state.text + '!'\n        }\n    }\n}\n\nexport default moduleA\n\n")])])]),n("p",[e._v("上方我们导出 A 模块，并在 index.js 中引入：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* index.js */\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport moduleA from './modules/moduleA'\nimport moduleB from './modules/moduleB'\nimport { mutations } from './mutations'\nimport actions from './actions'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: {\n        groups: [1]\n    },\n    modules: {\n        moduleA, // 引入 A 模块\n        moduleB, // 引入 B 模块\n    },\n    actions, // 根级别的 action\n    mutations, // 根级别的 mutations\n    \n    // 根级别的 getters\n    getters: {\n        getGroups (state) {\n            return state.groups\n        }\n    }   \n})\n\n")])])]),n("p",[e._v("这样项目中状态的模块划分就更加清晰，对应模块的状态我们只需要修改相应模块文件即可。详细的案例代码可参考文末 github 地址。")]),e._v(" "),n("h3",{attrs:{id:"_3-接口配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-接口配置"}},[e._v("#")]),e._v(" 3. 接口配置")]),e._v(" "),n("p",[e._v("在项目的开发过程中，我们也少不了与后台服务器进行数据的获取和交互，这一般都是通过接口完成的，那么我们如何进行合理的接口配置呢？我们可以在 src 目录下新建 services 文件夹用于存放接口文件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("└── src\n    └── services\n        ├── http.js      # 接口封装\n        ├── moduleA.js    # A模块接口\n        └── moduleB.js    # B模块接口\n\n")])])]),n("p",[e._v("为了让接口便于管理，我们同样使用不同的文件来配置不同模块的接口，同时由于接口的调用 ajax 请求代码重复部分较多，我们可以对其进行简单的封装，比如在 http.js 中（fetch为例）：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* http.js */\nimport 'whatwg-fetch'\n\n// HTTP 工具类\nexport default class Http {\n    static async request(method, url, data) {\n        const param = {\n            method: method,\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        };\n\n        if (method === 'GET') {\n            url += this.formatQuery(data)\n        } else {\n            param['body'] = JSON.stringify(data)\n        }\n\n        // Tips.loading(); // 可调用 loading 组件\n\n        return fetch(url, param).then(response => this.isSuccess(response))\n                .then(response => {\n                    return response.json()\n            })\n    }\n\n    // 判断请求是否成功\n    static isSuccess(res) {\n        if (res.status >= 200 && res.status < 300) {\n            return res\n        } else {\n            this.requestException(res)\n        }\n    }\n\n    // 处理异常\n    static requestException(res) {\n        const error = new Error(res.statusText)\n\n        error.response = res\n\n        throw error\n    }\n    \n    // url处理\n    static formatQuery(query) {\n        let params = [];\n\n        if (query) {\n            for (let item in query) {\n                let vals = query[item];\n                if (vals !== undefined) {\n                    params.push(item + '=' + query[item])\n                }\n            }\n        }\n        return params.length ? '?' + params.join('&') : '';\n    }\n    \n    // 处理 get 请求\n    static get(url, data) {\n        return this.request('GET', url, data)\n    }\n    \n    // 处理 put 请求\n    static put(url, data) {\n        return this.request('PUT', url, data)\n    }\n    \n    // 处理 post 请求\n    static post(url, data) {\n        return this.request('POST', url, data)\n    }\n    \n    // 处理 patch 请求\n    static patch(url, data) {\n        return this.request('PATCH', url, data)\n    }\n    \n    // 处理 delete 请求\n    static delete(url, data) {\n        return this.request('DELETE', url, data)\n    }\n}\n\n")])])]),n("p",[e._v("封装完毕后我们在 moduleA.js 中配置一个 github 的开放接口："),n("code",[e._v("https://api.github.com/repos/octokit/octokit.rb")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* moduleA.js */\nimport Http from './http'\n\n// 获取测试数据\nexport const getTestData = () => {\n    return Http.get('https://api.github.com/repos/octokit/octokit.rb')\n}\n\n")])])]),n("p",[e._v("然后在项目页面中进行调用，会成功获取 github 返回的数据，但是一般我们在项目中配置接口的时候会直接省略项目 url 部分，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* moduleA.js */\nimport Http from './http'\n\n// 获取测试数据\nexport const getTestData = () => {\n    return Http.get('/repos/octokit/octokit.rb')\n}\n\n")])])]),n("p",[e._v("这时候我们再次调用接口的时候会发现其调用地址为本地地址："),n("code",[e._v("http://127.0.0.1:8080/repos/octokit/octokit.rb")]),e._v("，那么为了让其指向 "),n("code",[e._v("https://api.github.com")]),e._v("，我们需要在 vue.config.js 中进行 devServer 的配置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* vue.config.js */\n\nmodule.exports = {\n    ...\n    \n    devServer: {\n    \n        // string | Object 代理设置\n        proxy: {\n        \n            // 接口是 '/repos' 开头的才用代理\n            '/repos': {\n                target: 'https://api.github.com', // 目标地址\n                changeOrigin: true, // 是否改变源地址\n                // pathRewrite: {'^/api': ''}\n            }\n        },\n    }\n    \n    ...\n}\n\n")])])]),n("p",[e._v("在 devServer 中 我们配置 proxy 进行接口的代理，将我们本地地址转换为真实的服务器地址，此时我们同样能顺利的获取到数据，不同点在于接口状态变成了 304（重定向）：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2020/08/vue/19.png",alt:""}})]),e._v(" "),n("h3",{attrs:{id:"_4-公共设施配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-公共设施配置"}},[e._v("#")]),e._v(" 4. 公共设施配置")]),e._v(" "),n("p",[e._v("最后我们项目开发中肯定需要对一些公共的方法进行封装使用，这里我把它称之为公共设施，那么我们可以在 src 目录下建一个 common 文件夹来存放其配置文件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("└── src\n    └── common\n        ├── index.js      # 公共配置入口\n        ├── validate.js   # 表单验证配置\n        └── other.js      # 其他配置\n\n")])])]),n("p",[e._v("在入口文件中我们可以向外暴露其他功能配置的模块，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* index.js */\nimport Validate from './validate'\nimport Other from './other'\n\nexport {\n    Validate,\n    Other,\n}\n\n")])])]),n("p",[e._v("这样我们在页面中只需要引入一个 index.js 即可。")]),e._v(" "),n("h2",{attrs:{id:"结语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),n("p",[e._v("本文介绍了 Vue 单页应用的一些基本配置，从项目构建层面阐述了各文件的主要配置方式和注意点，由于本文并不是一篇文档类的配置说明，并不会详细介绍各配置文件的 API 功能，大家可以访问文中列出的官方文档进行查阅。")]),e._v(" "),n("p",[e._v("本案例代码地址："),n("a",{attrs:{href:"https://github.com/luozhihao/vue-project-code/tree/master/single-page-project",target:"_blank",rel:"noopener noreferrer"}},[e._v("single-page-project"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"思考-作业"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思考-作业"}},[e._v("#")]),e._v(" 思考 & 作业")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("devServer 中 proxy 的 key 值代表什么？如果再添加一个 "),n("code",[e._v("/reposed")]),e._v(" 的配置会产生什么隐患？")])]),e._v(" "),n("li",[n("p",[e._v("如何配置 webpack 使得 "),n("code",[e._v("require.ensure()")]),e._v(" 拆分出的 js 文件具有自定义文件名？")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);