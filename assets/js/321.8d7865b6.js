(window.webpackJsonp=window.webpackJsonp||[]).push([[321],{873:function(t,e,_){"use strict";_.r(e);var v=_(10),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"一、setstate异步更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、setstate异步更新"}},[t._v("#")]),t._v(" 一、setState异步更新")]),t._v(" "),_("ul",[_("li",[t._v("我们都知道，"),_("code",[t._v("React")]),t._v("通过"),_("code",[t._v("this.state")]),t._v("来访问"),_("code",[t._v("state")]),t._v("，通过"),_("code",[t._v("this.setState()")]),t._v("方法来更新"),_("code",[t._v("state")]),t._v("。当"),_("code",[t._v("this.setState()")]),t._v("方法被调用的时候，"),_("code",[t._v("React")]),t._v("会重新调用"),_("code",[t._v("render")]),t._v("方法来重新渲染"),_("code",[t._v("UI")])]),t._v(" "),_("li",[t._v("首先如果直接在"),_("code",[t._v("setState")]),t._v("后面获取"),_("code",[t._v("state")]),t._v("的值是获取不到的。在"),_("code",[t._v("React")]),t._v("内部机制能检测到的地方， "),_("code",[t._v("setState")]),t._v("就是异步的；"),_("code",[t._v("在React")]),t._v("检测不到的地方，例如"),_("code",[t._v("setInterval")]),t._v(","),_("code",[t._v("setTimeout")]),t._v("，"),_("code",[t._v("setState")]),t._v("就是同步更新的")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/431.png",alt:""}})]),t._v(" "),_("blockquote",[_("p",[t._v("因为"),_("code",[t._v("setState")]),t._v("是可以接受两个参数的，一个"),_("code",[t._v("state")]),t._v("，一个回调函数。因此我们可以在回调函数里面获取值")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/432.png",alt:""}})]),t._v(" "),_("ul",[_("li",[_("code",[t._v("setState")]),t._v("方法通过一个队列机制实现"),_("code",[t._v("state")]),t._v("更新，当执行"),_("code",[t._v("setState")]),t._v("的时候，会将需要更新的"),_("code",[t._v("state")]),t._v("合并之后放入状态队列，而不会立即更新"),_("code",[t._v("this.state")])]),t._v(" "),_("li",[t._v("如果我们不使用"),_("code",[t._v("setState")]),t._v("而是使用"),_("code",[t._v("this.state.key")]),t._v("来修改，将不会触发组件的"),_("code",[t._v("re-render")]),t._v("。")]),t._v(" "),_("li",[t._v("如果将"),_("code",[t._v("this.state")]),t._v("赋值给一个新的对象引用，那么其他不在对象上的"),_("code",[t._v("state")]),t._v("将不会被放入状态队列中，当下次调用"),_("code",[t._v("setState")]),t._v("并对状态队列进行合并时，直接造成了"),_("code",[t._v("state")]),t._v("丢失")])]),t._v(" "),_("h3",{attrs:{id:"_1-1-setstate批量更新的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-setstate批量更新的过程"}},[t._v("#")]),t._v(" 1.1 setState批量更新的过程")]),t._v(" "),_("blockquote",[_("p",[t._v("在"),_("code",[t._v("react")]),t._v("生命周期和合成事件执行前后都有相应的钩子，分别是"),_("code",[t._v("pre")]),t._v("钩子和"),_("code",[t._v("post")]),t._v("钩子，"),_("code",[t._v("pre")]),t._v("钩子会调用"),_("code",[t._v("batchedUpdate")]),t._v("方法将"),_("code",[t._v("isBatchingUpdates")]),t._v("变量置为"),_("code",[t._v("true")]),t._v("，开启批量更新，而"),_("code",[t._v("post")]),t._v("钩子会将"),_("code",[t._v("isBatchingUpdates")]),t._v("置为"),_("code",[t._v("false")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/433.png",alt:""}})]),t._v(" "),_("ul",[_("li",[_("code",[t._v("isBatchingUpdates")]),t._v("变量置为"),_("code",[t._v("true")]),t._v("，则会走批量更新分支，"),_("code",[t._v("setState")]),t._v("的更新会被存入队列中，待同步代码执行完后，再执行队列中的"),_("code",[t._v("state")]),t._v("更新。 "),_("code",[t._v("isBatchingUpdates")]),t._v("为 "),_("code",[t._v("true")]),t._v("，则把当前组件（即调用了 "),_("code",[t._v("setState")]),t._v("的组件）放入 "),_("code",[t._v("dirtyComponents")]),t._v(" 数组中；否则 "),_("code",[t._v("batchUpdate")]),t._v(" 所有队列中的更新")]),t._v(" "),_("li",[t._v("而在原生事件和异步操作中，不会执行"),_("code",[t._v("pre")]),t._v("钩子，或者生命周期的中的异步操作之前执行了"),_("code",[t._v("pre")]),t._v("钩子，但是"),_("code",[t._v("pos")]),t._v("钩子也在异步操作之前执行完了，"),_("code",[t._v("isBatchingUpdates")]),t._v("必定为"),_("code",[t._v("false")]),t._v("，也就不会进行批量更新")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://poetries1.gitee.io/img-repo/2019/10/434.png",alt:""}})]),t._v(" "),_("blockquote",[_("p",[_("code",[t._v("enqueueUpdate")]),t._v("包含了"),_("code",[t._v("React")]),t._v("避免重复"),_("code",[t._v("render")]),t._v("的逻辑。"),_("code",[t._v("mountComponent")]),t._v("和"),_("code",[t._v("updateComponent")]),t._v("方法在执行的最开始，会调用到"),_("code",[t._v("batchedUpdates")]),t._v("进行批处理更新，此时会将"),_("code",[t._v("isBatchingUpdates")]),t._v("设置为"),_("code",[t._v("true")]),t._v("，也就是将状态标记为现在正处于更新阶段了。 "),_("code",[t._v("isBatchingUpdates")]),t._v("为 "),_("code",[t._v("true")]),t._v("，则把当前组件（即调用了 "),_("code",[t._v("setState")]),t._v(" 的组件）放入"),_("code",[t._v("dirtyComponents")]),t._v(" 数组中；否则 "),_("code",[t._v("batchUpdate")]),t._v(" 所有队列中的更新")])]),t._v(" "),_("h3",{attrs:{id:"_1-2-为什么直接修改this-state无效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-为什么直接修改this-state无效"}},[t._v("#")]),t._v(" 1.2 为什么直接修改this.state无效")]),t._v(" "),_("ul",[_("li",[t._v("要知道"),_("code",[t._v("setState")]),t._v("本质是通过一个队列机制实现"),_("code",[t._v("state")]),t._v("更新的。 执行"),_("code",[t._v("setState")]),t._v("时，会将需要更新的state合并后放入状态队列，而不会立刻更新"),_("code",[t._v("state")]),t._v("，队列机制可以批量更新"),_("code",[t._v("state")]),t._v("。")]),t._v(" "),_("li",[t._v("如果不通过"),_("code",[t._v("setState")]),t._v("而直接修改"),_("code",[t._v("this.state")]),t._v("，那么这个"),_("code",[t._v("state")]),t._v("不会放入状态队列中，下次调用"),_("code",[t._v("setState")]),t._v("时对状态队列进行合并时，会忽略之前直接被修改的"),_("code",[t._v("state")]),t._v("，这样我们就无法合并了，而且实际也没有把你想要的"),_("code",[t._v("state")]),t._v("更新上去")])]),t._v(" "),_("h3",{attrs:{id:"_1-3-什么是批量更新-batch-update"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-什么是批量更新-batch-update"}},[t._v("#")]),t._v(" 1.3 什么是批量更新 Batch Update")]),t._v(" "),_("blockquote",[_("p",[t._v("在一些"),_("code",[t._v("mv*")]),t._v("框架中，，就是将一段时间内对"),_("code",[t._v("model")]),t._v("的修改批量更新到"),_("code",[t._v("view")]),t._v("的机制。比如那前端比较火的"),_("code",[t._v("React")]),t._v("、"),_("code",[t._v("vue")]),t._v("（"),_("code",[t._v("nextTick")]),t._v("机制,视图的更新以及实现）")])]),t._v(" "),_("h3",{attrs:{id:"_1-4-setstate之后发生的事情"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-setstate之后发生的事情"}},[t._v("#")]),t._v(" 1.4 setState之后发生的事情")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("setState")]),t._v("操作并不保证是同步的，也可以认为是异步的")]),t._v(" "),_("li",[_("code",[t._v("React")]),t._v("在"),_("code",[t._v("setState")]),t._v("之后，会经对"),_("code",[t._v("state")]),t._v("进行"),_("code",[t._v("diff")]),t._v("，判断是否有改变，然后去"),_("code",[t._v("diff dom")]),t._v("决定是否要更新"),_("code",[t._v("UI")]),t._v("。如果这一系列过程立刻发生在每一个"),_("code",[t._v("setState")]),t._v("之后，就可能会有性能问题")]),t._v(" "),_("li",[t._v("在短时间内频繁"),_("code",[t._v("setState")]),t._v("。"),_("code",[t._v("React")]),t._v("会将"),_("code",[t._v("state")]),t._v("的改变压入栈中，在合适的时机，批量更新"),_("code",[t._v("state")]),t._v("和视图，达到提高性能的效果")])]),t._v(" "),_("h3",{attrs:{id:"_1-5-如何知道state已经被更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-如何知道state已经被更新"}},[t._v("#")]),t._v(" 1.5 如何知道state已经被更新")]),t._v(" "),_("blockquote",[_("p",[t._v("传入回调函数")])]),t._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    index"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("index"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),_("blockquote",[_("p",[t._v("在钩子函数中体现")])]),t._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUpdate")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("index"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("h2",{attrs:{id:"二、setstate循环调用风险"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、setstate循环调用风险"}},[t._v("#")]),t._v(" 二、setState循环调用风险")]),t._v(" "),_("ul",[_("li",[t._v("当调用"),_("code",[t._v("setState")]),t._v("时，实际上会执行"),_("code",[t._v("enqueueSetState")]),t._v("方法，并对"),_("code",[t._v("partialState")]),t._v("以及"),_("code",[t._v("_pending-StateQueue")]),t._v("更新队列进行合并操作，最终通过"),_("code",[t._v("enqueueUpdate")]),t._v("执行"),_("code",[t._v("state")]),t._v("更新")]),t._v(" "),_("li",[t._v("而"),_("code",[t._v("performUpdateIfNecessary")]),t._v("方法会获"),_("code",[t._v("取_pendingElement")]),t._v(","),_("code",[t._v("_pendingStateQueue")]),t._v("，"),_("code",[t._v("_pending-ForceUpdate")]),t._v("，并调用"),_("code",[t._v("receiveComponent")]),t._v("和"),_("code",[t._v("updateComponent")]),t._v("方法进行组件更新")]),t._v(" "),_("li",[t._v("如果在"),_("code",[t._v("shouldComponentUpdate")]),t._v("或者"),_("code",[t._v("componentWillUpdate")]),t._v("方法中调用"),_("code",[t._v("setState")]),t._v("，此时"),_("code",[t._v("this._pending-StateQueue != null")]),t._v("，就会造成循环调用，使得浏览器内存占满后崩溃")])]),t._v(" "),_("h2",{attrs:{id:"三、事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、事务"}},[t._v("#")]),t._v(" 三、事务")]),t._v(" "),_("ul",[_("li",[t._v("事务就是将需要执行的方法使用"),_("code",[t._v("wrapper")]),t._v("封装起来，再通过事务提供的"),_("code",[t._v("perform")]),t._v("方法执行，先执行"),_("code",[t._v("wrapper")]),t._v("中的"),_("code",[t._v("initialize")]),t._v("方法，执行完"),_("code",[t._v("perform")]),t._v("之后，在执行所有的"),_("code",[t._v("close")]),t._v("方法，一组"),_("code",[t._v("initialize")]),t._v("及"),_("code",[t._v("close")]),t._v("方法称为一个"),_("code",[t._v("wrapper")]),t._v("。")]),t._v(" "),_("li",[t._v("那么事务和"),_("code",[t._v("setState")]),t._v("方法的不同表现有什么关系，首先我们把"),_("code",[t._v("4")]),t._v("次"),_("code",[t._v("setStat")]),t._v("e简单归类，前两次属于一类，因为它们在同一调用栈中执行，"),_("code",[t._v("setTimeout")]),t._v("中的两次"),_("code",[t._v("setState")]),t._v("属于另一类")]),t._v(" "),_("li",[t._v("在"),_("code",[t._v("setState")]),t._v("调用之前，已经处在"),_("code",[t._v("batchedUpdates")]),t._v("执行的事务中了。那么这次"),_("code",[t._v("batchedUpdates")]),t._v("方法是谁调用的呢，原来是"),_("code",[t._v("ReactMount.js")]),t._v("中的"),_("code",[t._v("_renderNewRootComponent")]),t._v("方法。也就是说，整个将"),_("code",[t._v("React")]),t._v("组件渲染到"),_("code",[t._v("DOM")]),t._v("中的过程就是处于一个大的事务中。而在"),_("code",[t._v("componentDidMount")]),t._v("中调用"),_("code",[t._v("setState")]),t._v("时，"),_("code",[t._v("batchingStrategy")]),t._v("的"),_("code",[t._v("isBatchingUpdates")]),t._v("已经被设为了"),_("code",[t._v("true")]),t._v("，所以两次"),_("code",[t._v("setState")]),t._v("的结果没有立即生效")]),t._v(" "),_("li",[t._v("再反观"),_("code",[t._v("setTimeout")]),t._v("中的两次"),_("code",[t._v("setState")]),t._v("，因为没有前置的"),_("code",[t._v("batchedUpdates")]),t._v("调用，所以导致了新的"),_("code",[t._v("state")]),t._v("马上生效")])]),t._v(" "),_("h2",{attrs:{id:"四、总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、总结"}},[t._v("#")]),t._v(" 四、总结")]),t._v(" "),_("ul",[_("li",[t._v("通过"),_("code",[t._v("setState")]),t._v("去更新"),_("code",[t._v("this.state")]),t._v("，不要直接操作"),_("code",[t._v("this.state")]),t._v("，请把它当成不可变的")]),t._v(" "),_("li",[t._v("调用"),_("code",[t._v("setState")]),t._v("更新"),_("code",[t._v("this.state")]),t._v("不是马上生效的，它是异步的，所以不要天真以为执行完"),_("code",[t._v("setState")]),t._v("后"),_("code",[t._v("this.state")]),t._v("就是最新的值了")]),t._v(" "),_("li",[t._v("多个顺序执行的"),_("code",[t._v("setState")]),t._v("不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行，即批处理")])])])}),[],!1,null,null,null);e.default=a.exports}}]);